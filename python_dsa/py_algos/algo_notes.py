#(TEAM TREEHOUSE AND freeCodeCamp)

# 1. Start at beginning
# 2. Compare current value to target
# 3. Move sequentially
# 4. Reach end of list
# Otherwise, return nothing

 # GUIDELINES FOR ALGORITHMS
# - Specific order is VERY important
# - Each step should be explicitly clear and can't be broken down further. Must be distinct.
# - Algorithm must produce a result
# - Algorithms should actually complete and not take an infinite amount of time.
# Overall 
# - An Algorithm needs a clearly defined problem statement, input, and output.
# - The steps in the algorithm need to be in a very specific order.
# - The steps also need to be distinct.
# - The algorithm should produce a result.
# - The algorithm should complete in a finite amount of time.

# N = number of values in a worst case scenario
# Number of tries before reaching solution = Total Runtime
# Big O - Order of Growth - A notation used to describe complexity (of the upper bounds, or worst case scenario). (Order of magnitude of complexity)
# Big O is also a function of the size
# Complexity of one search algo is relative to other search algorithms

# =====

# All Polynomial runtimes - for a given val of n its worst case run time is O(n^k)
# Anything bounded by this, or that fall below O(n2) are considered efficient algorithms
# In exponential runtimes, if n increases slightly, the runtime increases exponentially and are far too expensive to be used O(x^n)
# Brute force algorithms have exponential runtimes
# 3 locks problem
# 10^2 -> 10^3 -> 10^4 2 digits to solve, to 3, to 4 = 1000 tries
# Traveling Salesman Problem n! n(n-1)(n-2)
# 3 routes = n combos -> 4 routes = n combos -> 5 routes = n combos
# 4! 4*3*2*1 = 24
# 200! 

